// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright Â© 2010-2018 ANSSI. All Rights Reserved.
/* 
 *  ckiutl.c - ckiutl main
 *  Copyright (C) 2010 SGDSN/ANSSI
 *  Author: Benjamin Morin <clipos@ssi.gouv.fr>
 *
 *  All rights reserved.
 *
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "protos.h"
#include "ckiutl.h"
#include <libp11.h>


const char *g_modulepath = "/usr/lib/p11proxy.so";
const char *g_label = NULL;
const char *g_pin = NULL;
const char *g_envvar = NULL;
const char *g_cacertpath = NULL;
const char *g_messagepath = NULL;
const char *g_signaturepath = NULL;
unsigned int g_nb_random_bytes = 0;
int g_debug = 0;

typedef enum {
	ActionEncrypt,
	ActionDecrypt,
	ActionSign,
	ActionVerify,
	ActionChangePin,
	ActionRemoveCert,
	ActionShowContent,
        ActionGenerateRandom,
	InvalidAction
} action_t;

typedef struct {
	const char *name;
	action_t action;
} action_map_t;

static const action_map_t g_action_map[] = {
  { "encrypt",	ActionEncrypt },
  { "decrypt", 	ActionDecrypt },
  { "sign",	ActionSign },
  { "verify", 	ActionVerify },
  { "changepin",	ActionChangePin },
  { "removecert",	ActionRemoveCert },
  { "show",	ActionShowContent },
  { "random",	ActionGenerateRandom },
  { NULL, InvalidAction }
};

static inline action_t 
get_action(const char *arg)
{
  const action_map_t *iter = g_action_map;
  
  while (iter->name) {
    if (!strcmp(arg, iter->name))
      return iter->action;
    iter++;
  }
  return InvalidAction;
}

static void
print_help(const char *prog)
{
  const action_map_t *iter = g_action_map;
  printf("%s [options] <action>\n", prog);
  puts("Actions:");
  while (iter->name) {
    fputs(iter->name, stdout);
    iter++;
    if (iter->name)
      putchar(',');
    else 
      putchar('\n');
  }
  puts("Options:");
  puts("-m <path>  : cryptoki library path");
  puts("-l <label> : object label on card");
  puts("-p <pin>   : pin code ");
  puts("-P <var>   : env. variable name where to get the pin code");
  puts("-c <path>  : CA pem path for certificate validation");
  puts("-s <path>  : signature file");
  puts("-M <path>  : message file");
  puts("-r <int>   : number of randomly generated bytes");
  puts("-d         : display debug messages");
  puts("-h         : display this help and exit");
}


static int
get_options(int argc, char *argv[])
{
  int c;
  
  while ((c = getopt(argc, argv, "M:s:m:l:p:P:c:dr:h")) != -1) {
    switch (c) {
    case 'M':
      g_messagepath = optarg;
      break;
    case 's':
      g_signaturepath = optarg;
      break;
    case 'm':
      g_modulepath = optarg;
      break;
    case 'l':
      g_label = optarg;
      break;
    case 'p':
      g_pin = optarg;
      break;
    case 'P':
      g_envvar = optarg;
      break;
    case 'c':
      g_cacertpath = optarg;
      break;
    case 'r':
      g_nb_random_bytes = atoi(optarg);
      break;
    case 'd':
      g_debug = 1;
      break;
    case 'h':
      print_help(basename(argv[0]));
      return EXIT_SUCCESS;
      break;
    default:
      return -1;
      break;
    }
  }
  return 0;
}




int
main(int argc, char *argv[])
{
  int rc = 0, ret = 0;

  ckitoken *tok = NULL;
  const char *pin = NULL;
  const char *cert_label = NULL;

  action_t action;

  if (get_options(argc, argv)) {
    _WARN("error parsing options\n");
    return EXIT_FAILURE;
  }

  argc -= optind;
  argv += optind;
  if (argc < 1) {
    _WARN("I need an action\n");
    return EXIT_FAILURE;
  }

  if(g_envvar) {
    pin = getenv(g_envvar);
  } else if(g_pin) {
    pin = g_pin;
  }

  if(g_label) {
    cert_label = g_label;
    if(strnlen(cert_label, MAX_LABEL_LEN) >= MAX_LABEL_LEN) {
      _WARN("label too long\n");
      return EXIT_FAILURE;
    }
  }

  tok = cki_newtok();
  if(!tok) {
    _ERROR("Could not create token object\n");
    exit(1);
  }

  _DEBUG("Initializing token\n");

  rc = cki_init(tok, g_modulepath);
  if(rc) {
    _ERROR("Could not initialize token object\n");
    exit(1);
  }

  _DEBUG("Gathering certs\n");

  action = get_action(argv[0]);

  switch(action) {

  case ActionDecrypt:
    if(cki_login(tok, pin)) break;
    if(cki_getcerts(tok)) break;
    do_decrypt(tok, cert_label);
    break;

  case ActionEncrypt:
    if(cki_getcerts(tok)) break;
    do_encrypt(tok, cert_label);
    break;

  case ActionSign:
    if(cki_login(tok, pin)) break;
    if(cki_getcerts(tok)) break;
    do_sign(tok, cert_label);
    break;

  case ActionVerify:
    if(cki_getcerts(tok)) break;
    if(cert_label == NULL) {
      printf("I need a certificate label\n");
      break;
    }
    if(g_messagepath == NULL) {
      printf("I need a message\n");
      break;
    }
    if(g_signaturepath == NULL) {
      printf("I need a signature to check\n");
      break;
    }
    do_verify(tok, g_messagepath, g_signaturepath, cert_label);
    break;

  case ActionChangePin:
    _WARN("action not implemented\n");
    break;

  case ActionRemoveCert:
    _WARN("action not implemented\n");
    break;

  case ActionShowContent:
    if(cki_login(tok, pin)) break;
    if(cki_getcerts(tok)) break;
    do_showcontent(tok);
    break;

  case ActionGenerateRandom:
    do_generaterandom(tok, g_nb_random_bytes);
    break;

  default: 
    _WARN("unknown action\n");
  }
  
  CRYPTO_cleanup_all_ex_data();
  ERR_free_strings();
  ERR_remove_state(0);

  _DEBUG("Freeing mem\n");
  cki_deltok(tok);

  return ret;
}


/*
int
checkcert(thecert)
{
    X509_check_ca (thecert->x509);

    X509_NAME_oneline (X509_get_subject_name (thecert->x509), subject, SIZE);
    X509_NAME_oneline (X509_get_issuer_name (thecert->x509), issuer, SIZE);
    and check x509->ex_kusage against :

  pu (keyUsage, KU_DIGITAL_SIGNATURE, "Digital Signature");
  pu (keyUsage, KU_NON_REPUDIATION, "Non Repudiation");
  pu (keyUsage, KU_KEY_ENCIPHERMENT, "Key Encipherment");
  pu (keyUsage, KU_DATA_ENCIPHERMENT, "Data Encipherment");
  pu (keyUsage, KU_KEY_AGREEMENT, "Key Agreement");
  pu (keyUsage, KU_KEY_CERT_SIGN, "Cert Sign");
  pu (keyUsage, KU_CRL_SIGN, "CRL Sign");
  pu (keyUsage, KU_ENCIPHER_ONLY, "Encipher Only");
  pu (keyUsage, KU_DECIPHER_ONLY, "Decipher Only");

  return 0;
}
*/
